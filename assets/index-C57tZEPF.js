(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const r of s.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&i(r)}).observe(document,{childList:!0,subtree:!0});function e(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(n){if(n.ep)return;n.ep=!0;const s=e(n);fetch(n.href,s)}})();class v{constructor(t,e){this.type=t.toUpperCase(),this.id=e,this.inputs=[],this.output=null}evaluate(t){if(!Array.isArray(t))return console.error(`Gate ${this.id} (${this.type}) requires an array of Boolean inputs.`),null;switch(this.type){case"AND":return this._validateInputs(t,2)?t.every(Boolean):null;case"OR":return this._validateInputs(t,2)?t.some(Boolean):null;case"NOT":return this._validateInputs(t,1)?!t[0]:null;case"XOR":return this._validateInputs(t,2)?t[0]!==t[1]:null;default:return console.error(`Unknown gate type: ${this.type}`),null}}_validateInputs(t,e){return t.length!==e?(console.error(`⚠️ Gate ${this.id} (${this.type}) requires ${e} input(s), but got ${t.length}.`),!1):t.every(i=>typeof i=="boolean")?!0:(console.error(`⚠️ Gate ${this.id} (${this.type}) requires Boolean inputs only.`),!1)}transferSignal(){const t=this.inputTerminal.parentNode.circuitBoard.gates.find(i=>i.id===this.inputTerminal.parentNode.id),e=this.outputTerminal.parentNode.circuitBoard.gates.find(i=>i.id===this.outputTerminal.parentNode.id);if(t&&e){const i=t.getSignal();console.log(`Transferring signal ${i} from ${t.id} to ${e.id}`),e.setInputs([i])}else console.error("Wire transfer failed: Invalid gates.")}setInputs(t){this.inputs=t,console.log(`Gate ${this.id} (${this.type}) inputs set to: ${t}`),this.output=this.evaluate(t)}}class b{constructor(t,e,i){if(!t||!e){console.error("❌ ERROR: Invalid terminals for connection.",t,e);return}this.inputTerminal=t,this.outputTerminal=e,this.container=i,this.element=this.createWireElement(),this.updatePosition()}createWireElement(){const t=document.createElement("div");return t.className="wire",t.style.position="absolute",t.style.backgroundColor="black",t.style.height="2px",t.style.pointerEvents="none",t.style.transition="width 0.3s ease-out",this.container.appendChild(t),t}updatePosition(){var h,$;const t=(h=this.inputTerminal.closest(".gate"))==null?void 0:h.getBoundingClientRect(),e=($=this.outputTerminal.closest(".gate"))==null?void 0:$.getBoundingClientRect(),i=this.container.getBoundingClientRect();if(!t||!e){console.warn("⚠️ Unable to calculate wire position. Terminal(s) might be missing.");return}const n=t.left+t.width/2-i.left,s=t.top+t.height/2-i.top,r=e.left+e.width/2-i.left,a=e.top+e.height/2-i.top,d=r-n,u=a-s,w=Math.atan2(u,d),p=Math.sqrt(d*d+u*u);this.element.style.width="0px",this.element.style.transformOrigin="0 0",this.element.style.transform=`rotate(${w}rad)`,this.element.style.left=`${n}px`,this.element.style.top=`${s}px`,setTimeout(()=>{this.element.style.width=`${p}px`},10)}}class y{constructor(t,e,i){this.id=t,this.container=e,this.state=!1,this.circuitBoard=i,this.element=document.getElementById(t)||this.createSwitchElement(),this.attachToggleEvent(),this.attachSounds(),this.setupEventListeners()}attachSounds(){this.switchSound=new Audio("./assets/Audio/switch.wav"),this.switchSound.volume=.5,this.switchSound.addEventListener("canplaythrough",()=>{console.log(`✅ Switch sound loaded for ${this.id}`)}),this.switchSound.canPlayType("audio/wav")||console.error(`❌ Switch sound format not supported: ${this.id}`)}setupEventListeners(){this.element.addEventListener("click",()=>{this.isOn=!this.isOn,this.element.classList.toggle("on",this.isOn),this.switchSound.play(),this.circuitBoard.updateAllWires()})}createSwitchElement(){const t=document.createElement("div");return t.id=this.id,t.className="switch off",t.textContent="",this.container.appendChild(t),t}toggle(){this.state=!this.state,this.element.classList.toggle("on",this.state),this.element.classList.toggle("off",!this.state),console.log(`🔀 Switch ${this.id} toggled ${this.state?"ON":"OFF"}`),this.circuitBoard?this.circuitBoard.updateAllWires():console.error(`⚠️ No circuit board found for Switch ${this.id}`)}attachToggleEvent(){this.element.addEventListener("click",()=>{this.toggle(),this.container.dispatchEvent(new CustomEvent("simulate"))})}getSignal(){return this.state}}class m{constructor(t,e){this.id=t,this.container=e,this.element=document.getElementById(t)||this.createBulbElement(),this.state=!1,this.attachSounds()}attachSounds(){this.bulbOnSound=new Audio("./assets/Audio/bulb.wav"),this.bulbOffSound=new Audio("./assets/Audio/bulb.wav"),this.bulbOnSound.volume=.5,this.bulbOffSound.volume=.5,console.log(`🔊 Lightbulb sounds loaded for ${this.id}`),(!this.bulbOnSound.canPlayType("audio/wav")||!this.bulbOffSound.canPlayType("audio/wav"))&&console.error("❌ Lightbulb sound format not supported")}createBulbElement(){const t=document.createElement("div");return t.id=this.id,t.className="lightbulb off",this.container.appendChild(t),t}turnOn(){this.state||(this.state=!0,this.element.classList.remove("off"),this.element.classList.add("on"),console.log(`LightBulb ${this.id} is ON`))}turnOff(){this.state&&(this.state=!1,this.element.classList.remove("on"),this.element.classList.add("off"),console.log(`💡 LightBulb ${this.id} is OFF`))}updateState(t){console.log(`💡 LightBulb ${this.id} received signal: ${t}`),t?this.turnOn():this.turnOff()}getSignal(){return this.state}turnOn(){this.element.classList.remove("off"),this.element.classList.add("on"),console.log(`LightBulb ${this.id} turned ON`)}turnOff(){this.element.classList.remove("on"),this.element.classList.add("off"),console.log(`LightBulb ${this.id} turned OFF`)}}class C{constructor(t){this.container=t,this.container.circuitBoard=this,this.gates=[],this.wires=[],this.currentConnection=null}loadFromData(t){this.resetBoard(),console.log("🔄 Loading circuit data...",t),t.gates.forEach(e=>{const{id:i,type:n,position:s}=e;if(!n){console.error("❌ Invalid gate type: undefined",e);return}let r=this.addGate(n,s.x,s.y);if(!r){console.error(`❌ Failed to add gate of type ${n} at (${s.x}, ${s.y})`);return}r.id=i,r.style.left=`${s.x}px`,r.style.top=`${s.y}px`;let a;n==="SWITCH"?(a=new y(i,r,this),a.attachSounds()):n==="BULB"?(a=new m(i,r,this),a.attachSounds()):a=new v(n,i,this),this.gates.push(a),console.log(`✅ Loaded ${n} gate with ID ${i} at (${s.x}, ${s.y})`)}),setTimeout(()=>{t.wires.forEach(e=>{console.log(`🔗 Reconnecting ${e.start} → ${e.end}`),this.connectGates(e.start,e.end)})},100),console.log("✅ Circuit loaded successfully!")}addGate(t,e,i){if(!["AND","OR","NOT","XOR","SWITCH","BULB"].includes(t))return console.error(`❌ Invalid gate type: ${t}`),null;const n=`${t.toLowerCase()}-${this.gates.length}`;if(document.getElementById(n))return console.warn(`⚠️ Gate with ID ${n} already exists. Skipping creation.`),null;const s=document.createElement("div");s.className="gate",s.id=n,s.style.position="absolute",s.style.left=`${e}px`,s.style.top=`${i}px`,t==="BULB"?s.classList.add("lightbulb","off"):t==="SWITCH"?s.classList.add("switch","off"):s.textContent=t,this.container.appendChild(s),this._enableGateDragging(s);let r;return t==="SWITCH"?r=new y(n,s,this):t==="BULB"?r=new m(n,s):r=new v(t,n,this),this.gates.push(r),console.log(`✅ Added ${t} gate with ID ${n} at (${e}, ${i})`),s}resetBoard(){console.log("🔄 Resetting circuit board..."),this.gates.forEach(t=>{const e=document.getElementById(t.id);e&&e.remove()}),document.querySelectorAll(".wire").forEach(t=>t.remove()),this.gates=[],this.wires=[],this.currentConnection=null,document.getElementById("canvas-placeholder").style.display="block",typeof f=="function"?f():console.warn("⚠️ initializeDragAndDrop is not defined."),console.log("✅ Circuit board reset complete. Wires removed.")}_enableGateDragging(t){let e=!1,i,n;t.addEventListener("mousedown",s=>{if(s.button!==0)return;const r=t.getBoundingClientRect(),a=this.container.getBoundingClientRect();i=s.clientX-r.left,n=s.clientY-r.top,e=!0,t.classList.add("dragging");const d=w=>{if(!e)return;let p=w.clientX-a.left-i,h=w.clientY-a.top-n;p=Math.max(0,Math.min(p,this.container.clientWidth-r.width)),h=Math.max(0,Math.min(h,this.container.clientHeight-r.height)),t.style.left=`${p}px`,t.style.top=`${h}px`,this.updateAllWires()},u=()=>{e=!1,t.classList.remove("dragging"),document.removeEventListener("mousemove",d),document.removeEventListener("mouseup",u)};document.addEventListener("mousemove",d),document.addEventListener("mouseup",u)}),t.ondragstart=()=>!1}connectGates(t,e){const i=document.getElementById(t),n=document.getElementById(e);if(!i||!n){console.error("❌ Invalid terminals for connection.");return}if(t.split("-")[0]===e.split("-")[0]){console.error("❌ Cannot connect a gate to itself.");return}const s=new b(i,n,this.container);this.wires||(this.wires=[]),this.wires.push(s),s.updatePosition(),console.log(`🔗 Connected ${t} → ${e}`),console.log(`🛠 Connecting ${t} (input) to ${e} (output)`),this.updateAllWires()}updateAllWires(){console.log("🔄 Updating all wires..."),this.wires.forEach(t=>{t.updatePosition(),console.log(`🔗 Wire updated: ${t.inputTerminal.id} → ${t.outputTerminal.id}`)}),this.gates.forEach(t=>{if(t instanceof m){const e=this._getInputsForGate(t);console.log(`💡 Inputs for LightBulb ${t.id}:`,e),e.some(n=>n===!0)?t.turnOn():t.turnOff()}else if(t instanceof v){const e=this._getInputsForGate(t);console.log(`⚙️ Inputs for Gate ${t.id} (${t.type}):`,e),t.setInputs(e)}})}_getInputsForGate(t){const i=this.wires.filter(n=>n.outputTerminal.id.includes(t.id)).map(n=>{let s=n.inputTerminal.closest(".gate");if(!s)return console.warn(`⚠️ Skipping wire connection. Parent node of ${n.inputTerminal.id} is the canvas.`),!1;const r=this.gates.find(a=>a.id===s.id);return r&&typeof r.getSignal=="function"?r.getSignal():(console.warn(`⚠️ Parent node of ${n.inputTerminal.id} does not have getSignal.`),!1)});return typeof t.setInputs=="function"&&t.setInputs(i),i}}async function B(o){try{await fetch("http://localhost:3001/saveCircuit",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o)}),console.log("✅ Circuit saved successfully!")}catch(t){console.error("❌ Error saving circuit:",t)}}async function L(){try{const o=await fetch("http://localhost:3001/loadCircuit");if(!o.ok)throw new Error("Failed to load circuit");const t=await o.json();return console.log("✅ Loaded circuit:",t),t}catch(o){return console.error("❌ Error loading circuit:",o),null}}let S=new Audio("/src/assets/Audio/switch.wav");window.bulbOnSound=new Audio("src/assets/Audio/bulb.wav");const g=document.getElementById("canvas"),l=new C(g);window.circuitBoard=l;document.getElementById("save-button").addEventListener("click",async()=>{console.log("Saving circuit...");const o={gates:l.gates.filter(t=>t).map(t=>{const e=document.getElementById(t.id);return e?{id:t.id,type:t.type||(t instanceof y?"SWITCH":t instanceof m?"BULB":"UNKNOWN"),position:{x:parseInt(e.style.left)||0,y:parseInt(e.style.top)||0}}:null}).filter(Boolean),wires:l.wires.filter(t=>t&&t.inputTerminal&&t.outputTerminal).map(t=>({start:t.inputTerminal.id,end:t.outputTerminal.id}))};console.log("Formatted circuit data:",o),B(o)});document.getElementById("load-button").addEventListener("click",async()=>{console.log("🔄 Loading circuit...");const o=await L();if(!o){console.error("❌ Failed to load circuit data.");return}console.log("✅ Data received:",o),window.circuitBoard.loadFromData(o)});document.addEventListener("DOMContentLoaded",async()=>{const o=await L();o&&console.log("Loaded saved circuit:",o)});function I(o){console.log(`🖱️ Gate clicked: ${o.id}`)}f();document.getElementById("reset-button").addEventListener("click",()=>{console.log("Reset button clicked."),l.resetBoard(),document.querySelectorAll(".gate").forEach(o=>o.remove()),document.querySelectorAll(".wire").forEach(o=>o.parentNode.removeChild(o)),l.wires&&(l.wires=[]),c=null,f()});document.addEventListener("DOMContentLoaded",async()=>{await L()&&console.log("Restoring saved circuit..."),document.getElementById("save-button").addEventListener("click",async()=>{console.log("🔄 Saving circuit...");const t={gates:l.gates.map(e=>({id:e.id,type:e.type,position:{x:e.x,y:e.y}})),wires:l.wires.map(e=>({start:e.startGate.id,end:e.endGate.id}))};await B(t)}),f()});function T(o){let t=!1,e,i;o.addEventListener("mousedown",n=>{if(n.button!==0)return;e=n.clientX-o.offsetLeft,i=n.clientY-o.offsetTop,t=!0;function s(a){t&&(o.style.left=`${a.clientX-e}px`,o.style.top=`${a.clientY-i}px`)}function r(){t=!1,o.classList.remove("dragging"),document.removeEventListener("mousemove",s),document.removeEventListener("mouseup",r)}document.addEventListener("mousemove",s),document.addEventListener("mouseup",r)}),o.ondragstart=()=>!1}function O(){console.log("🔊 Adding switch sound listeners..."),document.querySelectorAll(".switch").forEach(o=>{o.removeEventListener("click",E),o.addEventListener("click",E)})}function E(){console.log("🔊 Switch toggled"),S.currentTime=0,S.play(),console.log("🔄 Running simulateCircuit() after switch toggle..."),G()}function f(){console.log("🚀 Initialising drag-and-drop functionality..."),document.querySelectorAll(".gate-template").forEach(t=>{t.addEventListener("dragstart",e=>{const i=e.target.dataset.type;i&&(e.dataTransfer.setData("new-gate-type",i),t.classList.add("dragging"))}),t.addEventListener("dragend",()=>{t.classList.remove("dragging")})}),g.addEventListener("dragover",t=>{t.preventDefault()}),g.addEventListener("drop",t=>{t.preventDefault();const e=t.dataTransfer.getData("new-gate-type");if(!e){console.error("❌ Error: No gate type found.");return}console.log(`➕ Attempting to add new gate: ${e}`);const{x:i,y:n}=A(t,g);if(["SWITCH","BULB"].includes(e)&&document.querySelector(`.gate[data-type="${e}"]`)){console.warn(`⚠️ A ${e} already exists. Skipping addition.`);return}const s=document.querySelectorAll(`.gate[data-type="${e}"]`);if(!["SWITCH","BULB"].includes(e)&&s.length>0&&Array.from(s).find(d=>Math.abs(d.offsetLeft-i)<10&&Math.abs(d.offsetTop-n)<10)){console.warn(`⚠️ A ${e} gate already exists in this location. Skipping addition.`);return}const r=l.addGate(e,i,n);r?(r.setAttribute("data-type",e),T(r),e==="SWITCH"&&(r.classList.add("switch"),O()),r.addEventListener("click",a=>I(a))):console.warn("⚠️ Gate could not be added.")})}let c=null;g.addEventListener("click",o=>{let t=o.target;if(!t.classList.contains("gate")&&!t.classList.contains("switch")&&!t.classList.contains("lightbulb")){console.warn("⚠️ Clicked element is not a valid circuit component.");return}if(!c){c=t,c.classList.add("connecting"),console.log(`🔵 Selected ${c.id} as start of wire.`);return}c!==t?(console.log(`🔗 Connecting ${c.id} → ${t.id}`),typeof l.connectGates=="function"?l.connectGates(c.id,t.id):console.error("❌ ERROR: circuitBoard.connectGates is undefined."),typeof b<"u"?new b(c,t,g):console.error("❌ ERROR: Wire class is not defined.")):console.warn("❌ Cannot connect a gate to itself!"),c.classList.remove("connecting"),c=null});function A(o,t){const e=t.getBoundingClientRect();return{x:o.clientX-e.left,y:o.clientY-e.top}}function G(){console.log("🔄 Simulating the circuit...");const o=l.gates.find(n=>n instanceof y),t=l.gates.find(n=>n instanceof m);if(!o){console.warn("⚠️ No switch found in the circuit");return}if(!t){console.warn("⚠️ No lightbulb found in the circuit");return}const e=o.getSignal();console.log(`💡 Switch signal: ${e}`),l.updateAllWires();const i=l._getInputsForGate(t);console.log(`💡 Bulb inputs: ${i}`),!t.isOn&&i.some(n=>n===!0)?(console.log("💡 Bulb is turning ON!"),t.turnOn(),t.isOn=!0,console.log("🔊 Playing bulb sound..."),window.bulbOnSound.pause(),window.bulbOnSound.currentTime=0,window.bulbOnSound.src=window.bulbOnSound.src,window.bulbOnSound.load(),setTimeout(()=>{let n=window.bulbOnSound.play();n!==void 0&&n.catch(s=>console.warn("🔇 Audio playback prevented:",s))},50)):t.isOn&&!i.some(n=>n===!0)&&(console.log("💡 Bulb is turning OFF!"),t.turnOff(),t.isOn=!1,window.bulbOnSound.pause(),window.bulbOnSound.currentTime=0)}document.addEventListener("DOMContentLoaded",()=>{const o=["AND","OR","NOT","XOR","SWITCH","BULB"],t=document.getElementById("workspace");t.innerHTML="",o.forEach(e=>{const i=document.createElement("div");i.classList.add("gate-template"),i.textContent=e,i.setAttribute("data-type",e),i.draggable=!0,i.addEventListener("dragstart",n=>{n.dataTransfer.setData("new-gate-type",e),n.target.classList.add("dragging")}),i.addEventListener("dragend",()=>{i.classList.remove("dragging")}),t.appendChild(i)}),f(),O()});
